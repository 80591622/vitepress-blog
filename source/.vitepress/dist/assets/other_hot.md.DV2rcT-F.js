import{_ as e,c as t,o as a,a5 as r}from"./chunks/framework.BQQWXjGs.js";const d=JSON.parse('{"title":"火","description":"","frontmatter":{},"headers":[],"relativePath":"other/hot.md","filePath":"other/hot.md","lastUpdated":1714231776000}'),o={name:"other/hot.md"},l=r('<h1 id="火" tabindex="-1">火 <a class="header-anchor" href="#火" aria-label="Permalink to &quot;火&quot;">​</a></h1><h2 id="react-hooks" tabindex="-1">React Hooks <a class="header-anchor" href="#react-hooks" aria-label="Permalink to &quot;React Hooks&quot;">​</a></h2><p>2019 年 NPM 库下载量，React 再次荣登前端流行库榜首，用户数量还在不断增长。能保持第一位，React hooks 贡献满满。</p><h2 id="webassembly" tabindex="-1">WebAssembly <a class="header-anchor" href="#webassembly" aria-label="Permalink to &quot;WebAssembly&quot;">​</a></h2><p>WebAssembly 是一种新的字节码格式，目前主流浏览器都已经支WebAssembly。是由主流浏览器厂商组成的 W3C 社区团体制定的一个新的规范。可以接近原生的性能运行，并为诸如C / C ++等语言提供一个编译目标，以便它们可以在 Web 上运行。它也被设计为可以与 JavaScript 共存，允许两者一起工作。可以突破前端 3D game、 VR/AR 、 机器视觉、图像处理等运行速度瓶颈。 和 JS 需要解释执行不同的是，WebAssembly 字节码和底层机器码很相似，可以快速装载运行，因此性能相对于 JS 解释执行而言有了极大的提升。也就是说 WebAssembly 并不是一门编程语言，而是一份字节码标准，需要用高级编程语言编译出字节码放到 WebAssembly 虚拟机中才能运行，浏览器厂商需要做的就是根据 WebAssembly 规范实现虚拟机。有了 WebAssembly，在浏览器上可以跑任何语言。从 Coffee 到 TypeScript，到 Babel，这些都是需要转译为 js 才能被执行的，而 WebAssembly 是在浏览器里嵌入 vm，直接执行，不需要转译，执行效率自然高得多。</p><h2 id="pwa" tabindex="-1">PWA <a class="header-anchor" href="#pwa" aria-label="Permalink to &quot;PWA&quot;">​</a></h2><p>下一代 Web 应用。先说下当下 WebAPP 和 原生 APP。Web APP 对比 原生APP，开发成本低，适配多种移动设备，不用 IOS/安卓 多套代码，迭代更新容易，省去了审核、发包、各种渠道发布带来的时间损耗，无需安装成本，拿来即用。原生 APP也有它独到的优势，这些是 WebApp 所没有的优势我们也不知道以后会不会有突破。 PWA 能够显著提高应用加载速度，甚至让 web 应用可以在离线环境使用（Service Worker）。Web 应用能够像原生应用一样被添加到主屏、全屏执行 （Web App Manifest）进一步提高 Web 应用与操作系统集成能力，让 Web 应用能在未被激活时发起推送通知 （Push API 与 Notification API） 等等。</p><h2 id="graphql" tabindex="-1">GraphQL <a class="header-anchor" href="#graphql" aria-label="Permalink to &quot;GraphQL&quot;">​</a></h2><p>GraphQL 是一种新的 API 定义和查询语言，有可能成为新的 REST。它使 UI 组件易于声明式地获取数据，而不必关注后端实现细节。GraphQL 作为一种强大的抽象，可以加快应用开发速度，使代码更容易维护。新的一年，会作为技术点研究并在自己项目试用。</p><h2 id="serverless" tabindex="-1">Serverless <a class="header-anchor" href="#serverless" aria-label="Permalink to &quot;Serverless&quot;">​</a></h2><p><strong>阿里云的云服务</strong></p><p>要看</p><p>Nodejs 函数入口 <a href="https://help.aliyun.com/document_detail/74757.html" target="_blank" rel="noreferrer">https://help.aliyun.com/document_detail/74757.html</a></p><p>.funignore <a href="https://github.com/alibaba/funcraft/blob/master/docs/usage/getting_started-zh.md#funignore" target="_blank" rel="noreferrer">https://github.com/alibaba/funcraft/blob/master/docs/usage/getting_started-zh.md#funignore</a></p><p>fun deploy <a href="https://help.aliyun.com/document_detail/147077.html" target="_blank" rel="noreferrer">https://help.aliyun.com/document_detail/147077.html</a></p><p>---- 下面不建议看</p><p>函数计算冷启动优化最佳实践 <a href="https://help.aliyun.com/document_detail/140338.html" target="_blank" rel="noreferrer">https://help.aliyun.com/document_detail/140338.html</a></p><p>绑定自定义域名 <a href="https://help.aliyun.com/document_detail/90722.html" target="_blank" rel="noreferrer">https://help.aliyun.com/document_detail/90722.html</a></p><p>CDN 回源至函数计算 <a href="https://help.aliyun.com/document_detail/111175.html" target="_blank" rel="noreferrer">https://help.aliyun.com/document_detail/111175.html</a></p><p>配置 VPC 功能(访问rds) <a href="https://help.aliyun.com/knowledge_detail/72959.html" target="_blank" rel="noreferrer">https://help.aliyun.com/knowledge_detail/72959.html</a></p><p>函数计算 Custom Runtime 使用集锦 <a href="https://help.aliyun.com/document_detail/146732.html" target="_blank" rel="noreferrer">https://help.aliyun.com/document_detail/146732.html</a></p><p><a href="https://github.com/2627500295/serverless/tree/develop" target="_blank" rel="noreferrer">https://github.com/2627500295/serverless/tree/develop</a></p><p>--- Custom Runtime</p><p>自定义 node 版本 <a href="https://github.com/2627500295/function-compute-custom-runtime/tree/feature/custom-node-version" target="_blank" rel="noreferrer">https://github.com/2627500295/function-compute-custom-runtime/tree/feature/custom-node-version</a></p><p>使用 babel 运行 <a href="https://github.com/2627500295/function-compute-custom-runtime/tree/feature/custom-runtime-babel" target="_blank" rel="noreferrer">https://github.com/2627500295/function-compute-custom-runtime/tree/feature/custom-runtime-babel</a></p><h2 id="_5g" tabindex="-1">5G <a class="header-anchor" href="#_5g" aria-label="Permalink to &quot;5G&quot;">​</a></h2><p>2019年一个绕不开的话题就是5G。⾸先，5G 带宽的⼤幅提升带来传统 Web ⻚⾯复杂度的进⼀步提升，如同 2G 到 4G 变⾰过程中⻚⾯从 WAP 的纯⽂本超链接时代变⾰到 4G 全图⽚视频时代。5G 对于⻚⾯的变⾰必将是巨⼤的，但肯定不会⼀蹴⽽就。因为相应的配套设施也需要逐步完善，如硬件性能和浏览器的处理速度。⽽服务端渲染（SSR）肯定是其中⼀个捷径，轻前端重后台，5G 是桥梁，把渲染放后台，不像同构那么简单，需要关注和优化渲染性能。WebAssembly 或许会在这个机遇下得到快速发展，因为它可以⽆缝对接后台多种语⾔，⽽后台渲染的优化也会带来前端⻚⾯研发模式和技术架构的变⾰。</p><h2 id="protobuf" tabindex="-1">protobuf <a class="header-anchor" href="#protobuf" aria-label="Permalink to &quot;protobuf&quot;">​</a></h2><h2 id="typescript" tabindex="-1">Typescript <a class="header-anchor" href="#typescript" aria-label="Permalink to &quot;Typescript&quot;">​</a></h2><h2 id="flutter" tabindex="-1">Flutter <a class="header-anchor" href="#flutter" aria-label="Permalink to &quot;Flutter&quot;">​</a></h2><h2 id="小程序" tabindex="-1">小程序 <a class="header-anchor" href="#小程序" aria-label="Permalink to &quot;小程序&quot;">​</a></h2>',31),h=[l];function s(n,i,p,c,m,u){return a(),t("div",null,h)}const f=e(o,[["render",s]]);export{d as __pageData,f as default};
