import { ssrRenderAttrs, ssrRenderStyle } from "vue/server-renderer";
import { useSSRContext } from "vue";
import { _ as _export_sfc } from "./plugin-vue_export-helper.1tPrXgE0.js";
const __pageData = JSON.parse('{"title":"vite","description":"","frontmatter":{},"headers":[],"relativePath":"workspace/Vite/base.md","filePath":"workspace/Vite/base.md","lastUpdated":1713942612000}');
const _sfc_main = { name: "workspace/Vite/base.md" };
function _sfc_ssrRender(_ctx, _push, _parent, _attrs, $props, $setup, $data, $options) {
  _push(`<div${ssrRenderAttrs(_attrs)}><h1 id="vite" tabindex="-1">vite <a class="header-anchor" href="#vite" aria-label="Permalink to &quot;vite&quot;">​</a></h1><p><a href="https://github.com/vitejs/vite" target="_blank" rel="noreferrer">github 24k</a></p><p><code>Bundleless</code>, 本质上是将原先 Webpack 中模块依赖解析的工作交给浏览器去执行，使得在开发过程中代码的转换变少，极大地提升了开发过程中的构建速度，同时也可以更好地利用浏览器的相关开发工具。</p><hr><p>为什么会出现 Vite？在过去的 Webpack、Rollup 等构建工具的时代，我们所写的代码一般都是基于 ES Module 规范，在文件之间通过 <code>import</code> 和 <code>export</code> 形成一个很大的依赖图。</p><p>这些构建工具在本地开发调试的时候，也都会<strong>提前把你的模块</strong>先打包成浏览器可读取的 js <code>bundle</code>，虽然有诸如路由懒加载等优化手段，但懒加载并不代表懒构建，Webpack 还是需要把你的异步路由用到的模块提前构建好。</p><p>当你的项目越来越大的时候，启动也难免变的越来越慢，甚至可能达到分钟级别。而 <code>HMR</code> 热更新也会达到好几秒的耗时。</p><p>Vite 则别出心裁的利用了<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Modules" target="_blank" rel="noreferrer">浏览器的原生 ES Module 支持</a>，直接在 html 文件里写诸如这样的代码：</p><div class="language-html line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">html</span><pre class="shiki one-dark-pro vp-code"><code><span class="line"><span style="${ssrRenderStyle({ "color": "#ABB2BF" })}">// index.html</span></span>
<span class="line"><span style="${ssrRenderStyle({ "color": "#ABB2BF" })}">&lt;</span><span style="${ssrRenderStyle({ "color": "#E06C75" })}">div</span><span style="${ssrRenderStyle({ "color": "#D19A66" })}"> id</span><span style="${ssrRenderStyle({ "color": "#ABB2BF" })}">=</span><span style="${ssrRenderStyle({ "color": "#98C379" })}">&quot;app&quot;</span><span style="${ssrRenderStyle({ "color": "#ABB2BF" })}">&gt;&lt;/</span><span style="${ssrRenderStyle({ "color": "#E06C75" })}">div</span><span style="${ssrRenderStyle({ "color": "#ABB2BF" })}">&gt;</span></span>
<span class="line"><span style="${ssrRenderStyle({ "color": "#ABB2BF" })}">&lt;</span><span style="${ssrRenderStyle({ "color": "#E06C75" })}">script</span><span style="${ssrRenderStyle({ "color": "#D19A66" })}"> type</span><span style="${ssrRenderStyle({ "color": "#ABB2BF" })}">=</span><span style="${ssrRenderStyle({ "color": "#98C379" })}">&quot;module&quot;</span><span style="${ssrRenderStyle({ "color": "#ABB2BF" })}">&gt;</span></span>
<span class="line"><span style="${ssrRenderStyle({ "color": "#C678DD" })}">  import</span><span style="${ssrRenderStyle({ "color": "#ABB2BF" })}"> { </span><span style="${ssrRenderStyle({ "color": "#E06C75" })}">createApp</span><span style="${ssrRenderStyle({ "color": "#ABB2BF" })}"> } </span><span style="${ssrRenderStyle({ "color": "#C678DD" })}">from</span><span style="${ssrRenderStyle({ "color": "#98C379" })}"> &#39;vue&#39;</span></span>
<span class="line"><span style="${ssrRenderStyle({ "color": "#C678DD" })}">  import</span><span style="${ssrRenderStyle({ "color": "#E06C75" })}"> Main</span><span style="${ssrRenderStyle({ "color": "#C678DD" })}"> from</span><span style="${ssrRenderStyle({ "color": "#98C379" })}"> &#39;./main.vue&#39;</span></span>
<span class="line"></span>
<span class="line"><span style="${ssrRenderStyle({ "color": "#61AFEF" })}">  createApp</span><span style="${ssrRenderStyle({ "color": "#ABB2BF" })}">(</span><span style="${ssrRenderStyle({ "color": "#E06C75" })}">Main</span><span style="${ssrRenderStyle({ "color": "#ABB2BF" })}">).</span><span style="${ssrRenderStyle({ "color": "#61AFEF" })}">mount</span><span style="${ssrRenderStyle({ "color": "#ABB2BF" })}">(</span><span style="${ssrRenderStyle({ "color": "#98C379" })}">&#39;#app&#39;</span><span style="${ssrRenderStyle({ "color": "#ABB2BF" })}">)</span></span>
<span class="line"><span style="${ssrRenderStyle({ "color": "#ABB2BF" })}">&lt;/</span><span style="${ssrRenderStyle({ "color": "#E06C75" })}">script</span><span style="${ssrRenderStyle({ "color": "#ABB2BF" })}">&gt;</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br></div></div><p>Vite 会在本地帮你启动一个服务器，当浏览器读取到这个 html 文件之后，会在执行到 import 的时候才去向服务端发送 <code>Main.vue</code> 模块的请求，Vite 此时在利用内部的一系列黑魔法，包括 Vue 的 template 解析，代码的编译等等，解析成浏览器可以执行的 js 文件返回到浏览器端。</p><p>这就保证了只有在真正使用到这个模块的时候，浏览器才会请求并且解析这个模块，最大程度的做到了按需加载。</p><p>用 Vite 官网上的图来解释，传统的 bundle 模式是这样的：</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e1c187722cd9405687c6c0ff40b54b9b~tplv-k3u1fbpfcp-zoom-1.image" alt="传统 bundle"></p><p>而基于 ESM 的构建模式则是这样的：</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/af2907c55cdb4fedadf8e604907ddc57~tplv-k3u1fbpfcp-zoom-1.image" alt="基于 ESM"></p><p>灰色部分是暂时没有用到的路由，甚至完全不会参与构建过程，随着项目里的路由越来越多，构建速度也不会变慢。</p><p>webpack会先打包，然后启动开发服务器，请求服务器时直接给予打包结果。 而vite是直接启动开发服务器，请求哪个模块再对该模块进行实时编译。 由于现代浏览器本身就支持ES Module，会自动向依赖的Module发出请求。vite充分利用这一点，将开发环境下的模块文件，就作为浏览器要执行的文件，而不是像webpack那样进行打包合并。 由于vite在启动的时候不需要打包，也就意味着不需要分析模块的依赖、不需要编译，因此启动速度非常快。当浏览器请求某个模块时，再根据需要对模块内容进行编译。这种按需动态编译的方式，极大的缩减了编译时间，项目越复杂、模块越多，vite的优势越明显。 在HMR（热更新）方面，当改动了一个模块后，仅需让浏览器重新请求该模块即可，不像webpack那样需要把该模块的相关依赖模块全部编译一次，效率更高。 当需要打包到生产环境时，vite默认使用传统的rollup（也可以自己手动安装webpack来）进行打包，因此，vite的主要优势在开发阶段。另外，由于vite利用的是ES Module，因此在代码中（除了vite.config.js里面，这里是node的执行环境）不可以使用 CommonJS</p><h2 id="依赖预编译" tabindex="-1">依赖预编译 <a class="header-anchor" href="#依赖预编译" aria-label="Permalink to &quot;依赖预编译&quot;">​</a></h2><p>依赖预编译，其实是 Vite 2.0 在为用户启动开发服务器之前，先用 <code>esbuild</code> 把<code>检测到的依赖预先构建了一遍</code>。</p><p>也许你会疑惑，不是一直说好的 no-bundle 吗，怎么还是走启动时编译这条路线了？尤老师这么做当然是有理由的，我们先以导入 <code>lodash-es</code> 这个包为例。</p><p>当你用 <code>import { debounce } from &#39;lodash&#39;</code> 导入一个命名函数的时候，可能你理想中的场景就是浏览器去下载只包含这个函数的文件。但其实没那么理想，<code>debounce</code> 函数的模块内部又依赖了很多其他函数，形成了一个依赖图。</p><p>当浏览器请求 <code>debounce</code> 的模块时，又会发现内部有 2 个 <code>import</code>，再这样延伸下去，这个函数内部竟然带来了 600 次请求，耗时会在 1s 左右。</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d9273fbf819c430ea0a44677c789cf6b~tplv-k3u1fbpfcp-zoom-1.image" alt="lodash 请求依赖链路"></p><p>这当然是不可接受的，于是尤老师想了个折中的办法，正好利用 <a href="https://github.com/evanw/esbuild" target="_blank" rel="noreferrer">Esbuild</a> 接近无敌的构建速度，让你在没有感知的情况下在启动的时候预先帮你把 <code>debounce</code> 所用到的所有内部模块全部打包成一个传统的 <code>js bundle</code>。</p><h2 id="为啥生产模式不用-esbuild-不是更快吗" tabindex="-1">为啥生产模式不用 esbuild，不是更快吗？ <a class="header-anchor" href="#为啥生产模式不用-esbuild-不是更快吗" aria-label="Permalink to &quot;为啥生产模式不用 esbuild，不是更快吗？&quot;">​</a></h2><p>其实也想用，但是 esbuild 目前对生产包支持不够健壮，很多配置无法通过 esbuild 实现（1.esbuild虽然有loader，但是没有插件机制；2.esbuild没有热更新（Hot Module Replacement），对于开发来说会是一件非常痛苦的事情）。所以目前而言，Rollup 是一个好选择，虽然远比 esbuild 慢。</p><p>另外，可以用 esbuild 作为压缩器，替代 terser，详见 build.minify,这样会更快，但是包的体积可能会有 5% - 10% 左右的增长，看用户取舍。</p><p>弊端 开发运行没事，生产报错</p></div>`);
}
const _sfc_setup = _sfc_main.setup;
_sfc_main.setup = (props, ctx) => {
  const ssrContext = useSSRContext();
  (ssrContext.modules || (ssrContext.modules = /* @__PURE__ */ new Set())).add("workspace/Vite/base.md");
  return _sfc_setup ? _sfc_setup(props, ctx) : void 0;
};
const base = /* @__PURE__ */ _export_sfc(_sfc_main, [["ssrRender", _sfc_ssrRender]]);
export {
  __pageData,
  base as default
};
